{
  "version": 3,
  "sources": ["../src/remove-paywall.tsx", "../src/constants.ts", "../src/utils.ts"],
  "sourcesContent": ["import { Toast, getPreferenceValues, LaunchProps, open, showToast } from \"@raycast/api\";\nimport { DEFAULT_REMOVE_PAYWALL_SERVICE } from \"./constants\";\nimport { getUrl } from \"./utils\";\n\nexport default async (props: LaunchProps<{ arguments: Arguments.RemovePaywall }>) => {\n  let service: string;\n  if (props.arguments.service) {\n    service = props.arguments.service;\n  } else {\n    const preferences = getPreferenceValues<Preferences>();\n    service = preferences.service || DEFAULT_REMOVE_PAYWALL_SERVICE;\n  }\n\n  const urlArgument = props.arguments.url;\n  try {\n    const url = await getUrl(urlArgument);\n\n    if (typeof url !== \"string\") {\n      throw url;\n    }\n\n    // Open the URL with the specified service\n    open(`${service}/${url}`);\n  } catch (error) {\n    await showToast({\n      style: Toast.Style.Failure,\n      title: \"Cannot remove paywall\",\n      message: (error as Error).message,\n    });\n  }\n};\n", "export enum RemovePaywallService {\n  TwelveFt = \"https://12ft.io\",\n  ArchiveIs = \"https://archive.is\",\n  RemovePaywall = \"https://www.removepaywall.com\",\n  Freedium = \"https://freedium-mirror.cfd\",\n}\n\n// Default service used when the user hasn't chosen a preference\nexport const DEFAULT_REMOVE_PAYWALL_SERVICE = RemovePaywallService.TwelveFt;\n\n// A name mapping for display or config purposes (not currently used programmatically)\nexport const RemovePaywallServiceNames: Record<RemovePaywallService, string> = {\n  [RemovePaywallService.TwelveFt]: \"12ft (12ft.io)\",\n  [RemovePaywallService.ArchiveIs]: \"Archive (archive.is)\",\n  [RemovePaywallService.RemovePaywall]: \"RemovePaywall (removepaywall.com)\",\n  [RemovePaywallService.Freedium]: \"Freedium (freedium-mirror.cfd)\",\n};\n", "import { Clipboard, getSelectedText } from \"@raycast/api\";\nimport { RemovePaywallService } from \"./constants\";\nimport { runAppleScript, showFailureToast } from \"@raycast/utils\";\n\nconst urlRegex = /(https?:\\/\\/)?(www\\.)?[-a-zA-Z0-9@:%._+~#=]{2,256}\\.[a-z]{2,6}\\b([-a-zA-Z0-9@:%_+.~#?&//=]*)/;\n\ninterface BrowserInfo {\n  engine: \"webkit\" | \"chromium\" | \"gecko\";\n}\n\nconst SUPPORTED_BROWSERS: Record<string, BrowserInfo> = {\n  // WebKit\n  Safari: { engine: \"webkit\" },\n  Orion: { engine: \"webkit\" },\n  \"Orion RC\": { engine: \"webkit\" },\n\n  // Chromium\n  \"Google Chrome\": { engine: \"chromium\" },\n  \"Microsoft Edge\": { engine: \"chromium\" },\n  \"Brave Browser\": { engine: \"chromium\" },\n  Vivaldi: { engine: \"chromium\" },\n  Arc: { engine: \"chromium\" },\n\n  // Gecko\n  firefox: { engine: \"gecko\" },\n  zen: { engine: \"gecko\" },\n};\n\nfunction isUrl(text: string): boolean {\n  return urlRegex.test(text);\n}\n\nexport async function getUrl(urlArgument: string | undefined): Promise<string | Error> {\n  let url: string | undefined;\n\n  if (urlArgument) {\n    // If the user has provided a URL, use that\n    url = urlArgument;\n  } else {\n    try {\n      // If the user has selected text, use that as the URL\n      url = await getSelectedText();\n    } catch {\n      // Otherwise, use the clipboard\n      url = await Clipboard.readText();\n    }\n  }\n\n  if (!url) {\n    return new Error(\"No URL provided.\");\n  }\n\n  if (!isUrl(url)) {\n    return new Error(`Invalid URL: \"${url}\"`);\n  }\n\n  return url.trim();\n}\n\nasync function getActiveBrowserInfo(): Promise<{ name: string; engine: BrowserInfo[\"engine\"] }> {\n  const script = 'tell application \"System Events\" to get name of first application process whose frontmost is true';\n  let frontmostAppName: string;\n\n  try {\n    frontmostAppName = await runAppleScript(script);\n  } catch (error) {\n    await showFailureToast(error, {\n      title: \"Error Getting Active App\",\n      message: \"Could not determine the frontmost application.\",\n    });\n    throw new Error(\"Script failed to get frontmost application name.\");\n  }\n\n  const browserInfo = SUPPORTED_BROWSERS[frontmostAppName];\n  if (browserInfo) {\n    return { name: frontmostAppName, engine: browserInfo.engine };\n  } else {\n    return { name: frontmostAppName, engine: \"chromium\" };\n  }\n}\n\nexport async function getCurrentTabURL(): Promise<string> {\n  const browserInfo = await getActiveBrowserInfo();\n  const escapedBrowserName = browserInfo.name.replace(/\"/g, '\"\"');\n\n  let script = \"\";\n  if (browserInfo.engine === \"webkit\") {\n    script = `tell application \"${escapedBrowserName}\" to return URL of current tab of front window`;\n  } else if (browserInfo.engine === \"chromium\") {\n    script = `tell application \"${escapedBrowserName}\" to return URL of active tab of front window`;\n  } else if (browserInfo.engine === \"gecko\") {\n    script = `\n      tell application \"${escapedBrowserName}\"\n        activate\n      end tell\n      tell application \"System Events\"\n        keystroke \"l\" using command down\n        keystroke \"c\" using command down\n        delay 0.1\n      end tell\n      return the clipboard\n    `;\n  }\n\n  try {\n    return await runAppleScript(script);\n  } catch (error) {\n    await showFailureToast(error, {\n      title: `Failed to get URL from ${browserInfo.name}`,\n      message: \"Make sure the browser is running and a tab is active.\",\n    });\n    throw new Error(`Could not get URL from ${browserInfo.name}`);\n  }\n}\n\nexport async function openURL(url: string): Promise<void> {\n  const browserInfo = await getActiveBrowserInfo();\n  const escapedUrl = url.replace(/\"/g, '\"\"');\n  const escapedBrowserName = browserInfo.name.replace(/\"/g, '\"\"');\n  const script = `tell application \"${escapedBrowserName}\" to open location \"${escapedUrl}\"`;\n\n  try {\n    await runAppleScript(script);\n  } catch (error) {\n    await showFailureToast(error, {\n      title: `Failed to open URL in ${browserInfo.name}`,\n      message: \"Make sure the browser is running.\",\n    });\n    throw new Error(`Could not open URL in ${browserInfo.name}`);\n  }\n}\n\nexport function getRemovePaywallURL(currentURL: string, userPreferredService?: string): string {\n  if (currentURL.includes(\"medium.com\")) {\n    return `${RemovePaywallService.Freedium}/${currentURL}`;\n  } else {\n    if (!userPreferredService?.startsWith(\"https://\")) {\n      throw new Error(\"Preferred service must start with https://\");\n    }\n    return `${userPreferredService}/${currentURL}`;\n  }\n}\n"],
  "mappings": "0jBAAA,IAAAA,EAAA,GAAAC,EAAAD,EAAA,aAAAE,IAAA,eAAAC,EAAAH,GAAA,IAAAI,EAAyE,wBCQlE,IAAMC,EAAiC,kBCR9C,IAAAC,EAA2C,wB,uFAI3C,IAAMC,EAAW,+FAwBjB,SAASC,EAAMC,EAAuB,CACpC,OAAOC,EAAS,KAAKD,CAAI,CAC3B,CAEA,eAAsBE,EAAOC,EAA0D,CACrF,IAAIC,EAEJ,GAAID,EAEFC,EAAMD,MAEN,IAAI,CAEFC,EAAM,QAAM,mBAAgB,CAC9B,MAAQ,CAENA,EAAM,MAAM,YAAU,SAAS,CACjC,CAGF,OAAKA,EAIAL,EAAMK,CAAG,EAIPA,EAAI,KAAK,EAHP,IAAI,MAAM,iBAAiBA,CAAG,GAAG,EAJjC,IAAI,MAAM,kBAAkB,CAQvC,CFrDA,IAAOC,EAAQ,MAAOC,GAA+D,CACnF,IAAIC,EACAD,EAAM,UAAU,QAClBC,EAAUD,EAAM,UAAU,QAG1BC,KADoB,uBAAiC,EAC/B,SAAWC,EAGnC,IAAMC,EAAcH,EAAM,UAAU,IACpC,GAAI,CACF,IAAMI,EAAM,MAAMC,EAAOF,CAAW,EAEpC,GAAI,OAAOC,GAAQ,SACjB,MAAMA,KAIR,QAAK,GAAGH,CAAO,IAAIG,CAAG,EAAE,CAC1B,OAASE,EAAO,CACd,QAAM,aAAU,CACd,MAAO,QAAM,MAAM,QACnB,MAAO,wBACP,QAAUA,EAAgB,OAC5B,CAAC,CACH,CACF",
  "names": ["remove_paywall_exports", "__export", "remove_paywall_default", "__toCommonJS", "import_api", "DEFAULT_REMOVE_PAYWALL_SERVICE", "import_api", "urlRegex", "isUrl", "text", "urlRegex", "getUrl", "urlArgument", "url", "remove_paywall_default", "props", "service", "DEFAULT_REMOVE_PAYWALL_SERVICE", "urlArgument", "url", "getUrl", "error"]
}
